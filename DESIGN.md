# Design Decisions

Design decisions for QTube, both past and future, should be documented here. Even if nobody else should ever read this, it also reminds me of my own decisions in the future, so I can be more consistent and make better sense of the code and its architecture.

## Naming Convention

When I started writing QTube I had gone along with the coding convention of PyQt, which appears to go counter to the recommendations made by PEP, which is to use underscores in variable, function, and method names. I had done so without realizing it, because I had been influenced by the convention adopted in the PyQt classes I was overwhelmingly using. Later, I had made a TODO note to refactor my entire code to be compliant with PEP. As I started doing this, I noticed how the contrast with the PyQt convention became increasingly jarring and found this to be ugly. From what I recall, even the PEP guidelines state that, if there is a good reason for keeping consistency, as with the Python thread package classes they mention, then one can deviate from those recommendations. I think I have a similar justification for continuing the coding conventions I had unconsciously started out with, even if some people might find this ugly. Unless I hear of good reasons to refactor I am going to stick with it. One good reason, though, would be that the community interested in further developing this software, if there will ever be one, is overwhelmingly against the current conventions. If it holds back developer interest, then I would rather sacrifice my sense of aesthetics.

## Separation of Responsibility

Components are a good way to manage and isolate complexity. With more components, however, comes the need for more synchronization and communication. One way to manage that complexity is to assign a single component to be responsible and to be the authority of truth for a given set of data. In this player, the Playlist Manager is repsonsible for managing all data concerning playlists and tracks. As UIs and designs grow in complexity, more and more components depend on a given set of data. For example, several UI components might need the current tracks in the currently playing playlist and make updates to their data being displayed. Several components might also make changes to that data. It would probably be a bad design that all those components would need to know about each other and how they work. That way, when adding a new component, for example, all existing components that touch the data this new component needs would need to have their code updated to deal with this new component wherever they handle or change that shared data. 

Instead, here is the design decision I am setting out to follow. With there ideally being just one component that is responsible, i.e. authoritative, for a given set of data, all modifications and access to that data needs to be coordinated by that component. But that should not mean that this central component should need to know about all current and possible future components that might need access to its data. For example, it would be preferrable that the Playlist Manager does not to know how the Track View or the Playlist View works. Much less code complexity can be achieved if the Playlist Manager does not need to know about how its playlists, tracks, or any other data it manages, is displayed, now or in the future. Thus, I have decided that each authoritative component should behave similar to a service: any component that needs that service can subscribe whatever events it is interested in - in a manner that is transparent to the authoritative component. The approach that seemed a natural fit for this design are the signaling mechanisms provided by Qt. Not only can they serve this just described publisher-subscriber model, they also work across threads, of which this UI will need to make heavy use, in order to run a multitude of backgrounds tasks that must not block the main or UI thread.